#version 450
#extension GL_KHR_vulkan_glsl: enable
#include "noise3Dgrad.glsl"
#include "structures.glsl"
#include "simple_noise_filter.glsl"
#include "rigid_noise_filter.glsl"

layout(set = 0, binding = 0) uniform ComputeShaderParameters{
	uint bufferLength;
	uint width;
	uint height;
	uint depth;
} params;


layout(std430,set = 0, binding = 1) buffer VertexBuffer {
    Vertex vertexBuffer[];
};

layout(set = 0, binding = 2) uniform NoiseGeneratorParams{
	int noiseFilterCount;
	float planetRadius;
} noiseParams;

layout(std430, binding = 3) buffer NoiseSettings {
	GlobalNoiseSettings noiseSettings[];
};

layout(std430, binding = 4) buffer ElevationMinMax {
    
	int minElevation;
	int maxElevation;
}minMax;


float evaluate(GlobalNoiseSettings settings, vec3 point){	
	if(settings.filterType == 1){
		return evaluateRigid(settings,point);
	}
	return evaluateSimple(settings,point);
}
float QUANTIIZE_FACTOR = 32768.0;

layout(local_size_x = 2, local_size_y = 1, local_size_z = 1) in;
void main() {
	if(params.width <= gl_GlobalInvocationID.x || params.height <= gl_GlobalInvocationID.y){
	 	return; 
	}
	uint x = gl_GlobalInvocationID.x;
	uint y = gl_GlobalInvocationID.y;

	uint bufferIndex = y * params.width + x;
	//bufferIndex =  gl_GlobalInvocationID.x;

	Vertex v = vertexBuffer[bufferIndex];

	vec3 pos = vec3(v.positionX,v.positionY,v.positionZ);

	float firstLayerValue = 0;
	float elevation = 0;

	if(noiseParams.noiseFilterCount > 0){
		firstLayerValue = evaluate(noiseSettings[0], pos);
		if(noiseSettings[0].enabled == 1){
			elevation = firstLayerValue;
		}
	}
	
	for(int i = 1; i < noiseParams.noiseFilterCount; i++){
		
		if(noiseSettings[i].enabled == 1){
			float mask = noiseSettings[i].useFirstlayerAsMask == 1 ? firstLayerValue : 1.0;
			elevation += evaluate(noiseSettings[i], pos)*mask;
		}
	}
	elevation = noiseParams.planetRadius * (1.0 + elevation);

	pos *= elevation;
	v.positionX = pos.x;
	v.positionY = pos.y;
	v.positionZ = pos.z;
	vertexBuffer[bufferIndex] = v;
	
	float QUANTIIZE_FACTOR = 32768.0;

	int elevationForMinMax = int(elevation*QUANTIIZE_FACTOR);

	atomicMin(minMax.minElevation,elevationForMinMax);
	atomicMax(minMax.maxElevation,elevationForMinMax);
	// debug
	// GlobalNoiseSettings settingsTestOut = noiseSettings[0];
	// 
	// vec3 gradient;
	// float noiseOut = snoise(vec3(0), gradient);
	// float gradWeight = gradientWeight(gradient);

	//outbuf[0] = elevation;
	//outbuf[7] = elevation;
	//outbuf[8] = noiseParams.planetRadius;
	//outbuf[1] = pos.x;
	//outbuf[2] = pos.y;
	//outbuf[3] = pos.z;
	//pos *= elevation;
	//outbuf[4] = pos.x;
	//outbuf[5] = pos.y;
	//outbuf[6] = pos.z;

	// outbuf[0] = settingsTestOut.filterType;
	// outbuf[1] = settingsTestOut.strength;
	// outbuf[2] = settingsTestOut.numLayers;
	// outbuf[3] = settingsTestOut.baseRoughness;
	// outbuf[4] = settingsTestOut.roughness;
	// outbuf[5] = settingsTestOut.persistence;
	// 
	// outbuf[6] = settingsTestOut.centreX;
	// outbuf[7] = settingsTestOut.centreY;
	// outbuf[8] = settingsTestOut.centreZ;
	// 
	// outbuf[9] = settingsTestOut.offset;
	// outbuf[10] = settingsTestOut.minValue;
	// outbuf[11] = settingsTestOut.gradientWeight;
	// outbuf[12] = settingsTestOut.gradientWeightMul;
	// outbuf[13] = settingsTestOut.enabled;
	// outbuf[14] = settingsTestOut.useFirstlayerAsMask;
	// outbuf[15] = settingsTestOut.weightMultiplier;
}