#version 450
#extension GL_KHR_vulkan_glsl: enable
#include "structures.glsl"

// information about the main buffer defining what threads should run/abort
layout(set = 0, binding = 0) uniform ComputeShaderParameters{
	uint bufferLength;
	uint width;
	uint height;
	uint depth;
} params;


// vertex buffer to operate on (direct mesh buffer) Only read from here.
layout(std430,set = 0, binding = 1) readonly buffer VertexBuffer {
    Vertex vertexBuffer[];
};

// index buffer to operate on (direct mesh buffer) Only read from here.
layout(std430,set = 0, binding = 2) readonly buffer IndexBuffer {
    uint indexBuffer[];
};

// sizeof vertex buffer * 3 unormalized normals for each vertex expressed as ints to because atomic add
layout(std430,set = 0, binding = 3) buffer NormalBuffer {
    int normalBuffer[];
};

// fucked up float to int conversion magic number (2^16/2)
const float QUANTIIZE_FACTOR = 32768.0;

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main() {
	if(params.width <= gl_GlobalInvocationID.x || params.height <= gl_GlobalInvocationID.y){
	 	return; 
	}

	// iterating 1 triangle per thread, triangle made up of 3 indices
	uint indexBufferIndex = (gl_GlobalInvocationID.y * params.width + gl_GlobalInvocationID.x) * 3;

	uint indexA = indexBuffer[indexBufferIndex];
	uint indexB = indexBuffer[indexBufferIndex + 1];
	uint indexC = indexBuffer[indexBufferIndex + 2];

	vec3 posA = vec3(vertexBuffer[indexA].positionX,
	vertexBuffer[indexA].positionY,
	vertexBuffer[indexA].positionZ);
	
	vec3 posB = vec3( vertexBuffer[indexB].positionX,
	vertexBuffer[indexB].positionY,
	vertexBuffer[indexB].positionZ);

	vec3 posC = vec3(vertexBuffer[indexC].positionX,
	vertexBuffer[indexC].positionY,
	vertexBuffer[indexC].positionZ);

	// compute face normal, remap the vec3 as an int vec3 for atomic add
	ivec3 faceNormal = ivec3(normalize(cross(posB - posA, posC - posA)) * QUANTIIZE_FACTOR);
	
	// to write into the normal buffer multiply indices by 3 again for each component.
	indexA *= 3;
	indexB *= 3;
	indexC *= 3;
	atomicAdd(normalBuffer[indexA],faceNormal.x);
	atomicAdd(normalBuffer[indexA + 1], faceNormal.y);
	atomicAdd(normalBuffer[indexA + 2], faceNormal.z);
	atomicAdd(normalBuffer[indexB], faceNormal.x);
	atomicAdd(normalBuffer[indexB + 1], faceNormal.y);
	atomicAdd(normalBuffer[indexB + 2], faceNormal.z);
	atomicAdd(normalBuffer[indexC], faceNormal.x);
	atomicAdd(normalBuffer[indexC + 1], faceNormal.y);
	atomicAdd(normalBuffer[indexC + 2], faceNormal.z);

}