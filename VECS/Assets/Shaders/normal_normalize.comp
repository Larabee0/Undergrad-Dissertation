#version 450
#extension GL_KHR_vulkan_glsl: enable
#include "structures.glsl"

// information about the main buffer defining what threads should run/abort
layout(set = 0, binding = 0) uniform ComputeShaderParameters{
	uint bufferLength;
	uint width;
	uint height;
	uint depth;
} params;


// vertex buffer to operate on (direct mesh buffer) Read/Write here.
// layout(std430,set = 0, binding = 1) buffer VertexBuffer {
//     vec4 vertexBuffer[];
// };

// sizeof vertex buffer * 3 un-normalized normals for each vertex expressed as ints to because atomic add
layout(std430,set = 0, binding = 1) readonly buffer NormalBuffer {
    int normalBuffer[];
};
// the normal buffer to write into, this is actually the same as the buffer above
// this is interpretened as floats to allow the normalized value to be written
layout(std430,set = 0, binding = 2) writeonly buffer NormalBufferWrite {
    float normalBufferWrite[];
};
// fucked up float to int conversion magic number (2^16/2)
const float QUANTIIZE_FACTOR = 32768.0;

layout(local_size_x =1, local_size_y = 1, local_size_z = 1) in;
void main() {
	if(params.width <= gl_GlobalInvocationID.x || params.height <= gl_GlobalInvocationID.y){
	 	return; 
	}

	uint bufferIndex = gl_GlobalInvocationID.y * params.width + gl_GlobalInvocationID.x;

	uint normalIndex = bufferIndex * 3;

	// convert each component of the normal vector back to a float and normalize the vector
	vec3 norm = vec3(normalBuffer[normalIndex], normalBuffer[normalIndex + 1], normalBuffer[normalIndex + 2]) / QUANTIIZE_FACTOR;
	norm = normalize(norm);

	// set vertex normal
	normalBufferWrite[normalIndex] = norm.x;	 
	normalBufferWrite[normalIndex + 1] = norm.y;	
	normalBufferWrite[normalIndex + 2] = norm.z;
}